import { type NextRequest, NextResponse } from 'next/server'
import { getToken } from 'next-auth/jwt'

import { getLogger } from '@/lib/monitoring/logger'

import type { Prisma } from '@prisma/client'

// JWT Token interface
interface AuthToken {
  user_id: string
  email: string
  role: string
  name?: string
  picture?: string
  sub?: string
  iat?: number
  exp?: number
  jti?: string
}

// Admin role checking middleware
export async function withAdminAuth(
  request: NextRequest,
  handler: (request: NextRequest, user: AuthToken) => Promise<NextResponse>
): Promise<NextResponse> {
  try {
    // Get JWT token from request
    const token = await getToken({
      req: request,
      secret: process.env.NEXTAUTH_SECRET
    })

    // Check if user is authenticated
    if (!token) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    // Check if user has admin role
    if (token.role !== 'admin' && token.role !== 'superadmin') {
      return NextResponse.json({ error: 'Admin access required' }, { status: 403 })
    }

    // User is authenticated and has admin role
    return handler(request, token as AuthToken)
  } catch (error) {
    getLogger().error(
      'Admin auth middleware error',
      error instanceof Error ? error : new Error(String(error))
    )
    return NextResponse.json({ error: 'Authentication check failed' }, { status: 500 })
  }
}

// Super admin role checking middleware
export async function withSuperAdminAuth(
  request: NextRequest,
  handler: (request: NextRequest, user: AuthToken) => Promise<NextResponse>
): Promise<NextResponse> {
  try {
    const token = await getToken({
      req: request,
      secret: process.env.NEXTAUTH_SECRET
    })

    if (!token) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    if (token.role !== 'superadmin') {
      return NextResponse.json({ error: 'Super admin access required' }, { status: 403 })
    }

    return handler(request, token as AuthToken)
  } catch (error) {
    getLogger().error(
      'Super admin auth middleware error',
      error instanceof Error ? error : new Error(String(error))
    )
    return NextResponse.json({ error: 'Authentication check failed' }, { status: 500 })
  }
}

// Customer role checking middleware
export async function withCustomerAuth(
  request: NextRequest,
  handler: (request: NextRequest, user: AuthToken) => Promise<NextResponse>
): Promise<NextResponse> {
  try {
    const token = await getToken({
      req: request,
      secret: process.env.NEXTAUTH_SECRET
    })

    if (!token) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    // Allow admin, superadmin, or customer
    const allowedRoles = ['customer', 'admin', 'superadmin']
    if (!allowedRoles.includes(token.role)) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    return handler(request, token as AuthToken)
  } catch (error) {
    getLogger().error(
      'Customer auth middleware error',
      error instanceof Error ? error : new Error(String(error))
    )
    return NextResponse.json({ error: 'Authentication check failed' }, { status: 500 })
  }
}

// Role-based access control helper
export function hasPermission(userRole: string, requiredRoles: string[]): boolean {
  // Superadmin has access to everything
  if (userRole === 'superadmin') {
    return true
  }

  // Admin has access to most things except superadmin-only features
  if (userRole === 'admin' && !requiredRoles.includes('superadmin')) {
    return true
  }

  // Check specific role requirements
  return requiredRoles.includes(userRole)
}

// Resource ownership checking
export async function checkResourceOwnership(
  user_id: string,
  resourceType: 'booking' | 'payment' | 'user',
  resource_id: string
): Promise<boolean> {
  try {
    const { prisma } = await import('@/lib/db')

    switch (resourceType) {
      case 'booking': {
        const booking = await prisma.bookings.findUnique({
          where: { id: resource_id },
          select: { user_id: true }
        })
        return booking?.user_id === user_id
      }

      case 'payment': {
        const payment = await prisma.payments.findUnique({
          where: { id: resource_id },
          include: { bookings: { select: { user_id: true } } }
        })
        return payment?.bookings?.user_id === user_id
      }

      case 'user':
        return resource_id === user_id

      default:
        return false
    }
  } catch (error) {
    getLogger().error(
      'Resource ownership check failed',
      error instanceof Error ? error : new Error(String(error)),
      { resourceType, resource_id, user_id }
    )
    return false
  }
}

// API endpoint protection wrapper
export function protectApiRoute(requiredRole: 'admin' | 'superadmin' | 'customer' = 'customer') {
  return function (
    handler: (
      request: NextRequest & { user?: AuthToken },
      context?: unknown
    ) => Promise<NextResponse>
  ) {
    return async function (request: NextRequest, context?: unknown) {
      const middlewareMap = {
        admin: withAdminAuth,
        superadmin: withSuperAdminAuth,
        customer: withCustomerAuth
      }

      const middleware = middlewareMap[requiredRole]

      return middleware(request, (req, user) => {
        // Add user info to request context
        const requestWithUser = Object.assign(req, { user })
        return handler(requestWithUser, context)
      })
    }
  }
}

// Client-side role checking for pages
export function useAdminCheck() {
  if (typeof window === 'undefined') {
    return { isAdmin: false, isLoading: true }
  }

  // This would typically use a React hook to check user session
  // For now, return a placeholder
  return { isAdmin: false, isLoading: false }
}

// Admin route protection for pages
export async function requireAdminAccess(request: NextRequest): Promise<{
  allowed: boolean
  user?: AuthToken
  redirectUrl?: string
}> {
  try {
    const token = await getToken({
      req: request,
      secret: process.env.NEXTAUTH_SECRET
    })

    if (!token) {
      // Log unauthorized access attempt
      await logSecurityEvent('unauthorized_admin_access', {
        url: request.url,
        ip: request.headers.get('x-forwarded-for') ?? 'unknown',
        user_agent: request.headers.get('user-agent')
      })

      return {
        allowed: false,
        redirectUrl: '/auth/signin?callbackUrl=' + encodeURIComponent(request.url)
      }
    }

    if (token.role !== 'admin' && token.role !== 'superadmin') {
      // Log access denied attempt
      await logSecurityEvent('admin_access_denied', {
        user_id: token.user_id,
        userRole: token.role,
        url: request.url,
        ip: request.headers.get('x-forwarded-for') ?? 'unknown'
      })

      return {
        allowed: false,
        redirectUrl: '/auth/error?error=accessdenied'
      }
    }

    // Log successful admin access
    await logSecurityEvent('admin_access_granted', {
      user_id: token.user_id,
      userRole: token.role,
      url: request.url
    })

    return {
      allowed: true,
      user: {
        user_id: token.sub ?? '',
        email: token.email ?? '',
        role: 'admin',
        name: token.name
      } as AuthToken
    }
  } catch (error) {
    getLogger().error(
      'Admin access check failed',
      error instanceof Error ? error : new Error(String(error))
    )
    return {
      allowed: false,
      redirectUrl: '/auth/error?error=configuration'
    }
  }
}

// Security event logging helper
async function logSecurityEvent(event: string, data: Record<string, unknown>) {
  try {
    const { prisma } = await import('@/lib/db')
    await prisma.security_logs.create({
      data: {
        id: crypto.randomUUID(),
        event,
        user_id: data.user_id as string | undefined,
        ip: data.ip as string | undefined,
        user_agent: data.user_agent as string | undefined,
        url: data.url as string | undefined,
        data: data as Prisma.InputJsonValue,
        timestamp: new Date()
      }
    })
  } catch (error) {
    getLogger().warn(
      `Failed to log security event: ${error instanceof Error ? error.message : String(error)}`,
      { event }
    )
    // Fallback logging
    getLogger().warn(`SECURITY EVENT: ${event}`, {
      data: JSON.stringify(data),
      timestamp: new Date().toISOString()
    })
  }
}

// Audit logging for admin actions
export async function logAdminAction(
  adminId: string,
  action: string,
  resource: string,
  resource_id: string,
  details?: Record<string, unknown>
): Promise<void> {
  try {
    const { prisma } = await import('@/lib/db')

    await prisma.audit_logs.create({
      data: {
        id: crypto.randomUUID(),
        user_id: adminId,
        action,
        resource,
        resource_id,
        details: details as Prisma.InputJsonValue,
        ip: details?.ip as string | undefined,
        user_agent: details?.user_agent as string | undefined,
        timestamp: new Date()
      }
    })

    getLogger().info('Audit log created', { adminId, action, resource, resource_id })
  } catch (error) {
    getLogger().warn(
      `Failed to log admin action: ${error instanceof Error ? error.message : String(error)}`,
      { action, resource }
    )
    // Fallback to console logging for critical security events
    getLogger().error('SECURITY AUDIT FAILED', error as Error, {
      timestamp: new Date().toISOString(),
      adminId,
      action,
      resource,
      resource_id,
      details: JSON.stringify(details)
    })
  }
}

// Rate limiting for admin actions
const adminActionLimits = new Map<string, { count: number; resetTime: number }>()

export function checkAdminRateLimit(
  adminId: string,
  action: string,
  maxRequests = 100,
  windowMs = 60000 // 1 minute
): boolean {
  const key = `${adminId}:${action}`
  const now = Date.now()
  const limit = adminActionLimits.get(key)

  if (!limit ?? now > limit.resetTime) {
    // Reset or create new limit
    adminActionLimits.set(key, {
      count: 1,
      resetTime: now + windowMs
    })
    return true
  }

  if (limit.count >= maxRequests) {
    return false
  }

  limit.count++
  return true
}

// Export commonly used permissions
export const ADMIN_PERMISSIONS = {
  READ_USERS: ['admin', 'superadmin'],
  WRITE_USERS: ['admin', 'superadmin'],
  DELETE_USERS: ['superadmin'],
  READ_BOOKINGS: ['admin', 'superadmin'],
  WRITE_BOOKINGS: ['admin', 'superadmin'],
  DELETE_BOOKINGS: ['superadmin'],
  READ_PAYMENTS: ['admin', 'superadmin'],
  WRITE_PAYMENTS: ['admin', 'superadmin'],
  READ_ANALYTICS: ['admin', 'superadmin'],
  SYSTEM_SETTINGS: ['superadmin']
} as const
